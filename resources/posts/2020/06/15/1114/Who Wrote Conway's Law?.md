When I think about the intersection of people and code, Conway's Law comes immediately to mind. If you're not familiar with it, this is the idea that companies tend to ship their org charts in code.
But not all projects are built by corporate hierarchies. What does the codebase to a large project like Linux or Python look like? Do they have org charts?
Sometimes Conway's Law is used as a joke, but in it lies the germ of an important notion: that code is related to politics, and thus into governance.
The material problem that has been leading my thoughts to this is consensus. I've been getting up to speed on a new codebase. I like that, for the most part, things are done the same way in this codebase. I don't have to learn the parochial style of one region of the codebase before I mine it or add to it.
The reason that is the case is organizational. Say that you have a bad codebase with no tests, no testability, and complexity run wild. This is bad enough on its own, but even the best engineering talent with the best practices in mind can fail to improve things to their satisfaction, because they fail to achieve consensus with the rest of the organization about what they are going to do. The result is either they bounce off the organization and go elsewhere, or they end up achieve a factional codebase with fiefdoms of differing style that fail to interoperate cleanly.
This may seem like other people's problems, but codebases aren't static things. Today's state of the art codebase is tomorrow's Java legacy monolith that nobody wants to work on. Someday, a change will need to be made that everyone in the working group needs to take action on together, not just pay lip service to. If that day hasn't already occurred for your codebase, rest assured that it will in the future.
There's an aphorism about testing that goes something like this: Just because you don't write tests doesn't mean you don't have a testing strategy. The same applies to governance in our codebases: just because you don't have a strategy doesn't mean it's not there.
And that's my hypothesis for why Conway's Law exists: because when you work in a corporation with a hierarchical org chart, that is the default. Does it have to be that way? How are projects in the real world actually governed? Does Linux or Python have an org chart?
